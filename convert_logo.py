#!/usr/bin/env python3
"""
Convert PNG images to C headers based on XML configuration.
Supports RGB565 (16-bit) and RGB888 (24-bit packed) formats.
Format is determined by parsing main/main.h for SCREEN_FORMAT_* define.
"""

from PIL import Image
import xml.etree.ElementTree as ET
import sys
import os
import re

# Configuration paths
XML_CONFIG = "images.xml"
HEADER_CONFIG = "main/main.h"

def detect_screen_format():
    """Parse main/main.h to detect SCREEN_FORMAT_RGB888 or SCREEN_FORMAT_RGB565."""
    try:
        with open(HEADER_CONFIG, 'r') as f:
            content = f.read()

        # Look for uncommented SCREEN_FORMAT defines
        # Ignore lines that are commented out with //
        if re.search(r'^(?!.*//.*SCREEN_FORMAT_RGB888).*#define\s+SCREEN_FORMAT_RGB888', content, re.MULTILINE):
            return 'RGB888'
        elif re.search(r'^(?!.*//.*SCREEN_FORMAT_RGB565).*#define\s+SCREEN_FORMAT_RGB565', content, re.MULTILINE):
            return 'RGB565'
        else:
            print(f"Error: Could not detect SCREEN_FORMAT in {HEADER_CONFIG}")
            print("Expected: #define SCREEN_FORMAT_RGB888 or #define SCREEN_FORMAT_RGB565")
            sys.exit(1)
    except FileNotFoundError:
        print(f"Error: Could not find {HEADER_CONFIG}")
        sys.exit(1)

def rgb888_to_rgb565(r, g, b):
    """Convert 24-bit RGB to 16-bit RGB565 format."""
    r5 = (r >> 3) & 0x1F
    g6 = (g >> 2) & 0x3F
    b5 = (b >> 3) & 0x1F
    return (r5 << 11) | (g6 << 5) | b5

def convert_image(source_path, target_path, image_name, format_type):
    """
    Convert a PNG image to C header file.

    Args:
        source_path: Path to input PNG file
        target_path: Path to output C header file
        image_name: Base name for generated constants
        format_type: 'RGB565' or 'RGB888'
    """
    print(f"\nProcessing: {source_path}")

    # Load image
    try:
        img = Image.open(source_path).convert("RGBA")
    except FileNotFoundError:
        print(f"  Error: File not found: {source_path}")
        return False

    width, height = img.size
    print(f"  Size: {width}×{height}")

    # Flatten transparency onto black background
    black_bg = Image.new("RGB", (width, height), (0, 0, 0))
    black_bg.paste(img, (0, 0), img)
    pixels = black_bg.load()

    # Convert based on format
    if format_type == 'RGB565':
        print(f"  Converting to RGB565 (16-bit)...")
        pixel_data = []
        for y in range(height):
            for x in range(width):
                r, g, b = pixels[x, y]
                rgb565 = rgb888_to_rgb565(r, g, b)
                pixel_data.append(rgb565)

        data_type = "uint16_t"
        bytes_per_pixel = 2

    else:  # RGB888
        print(f"  Converting to RGB888 (24-bit packed)...")
        pixel_data = []
        for y in range(height):
            for x in range(width):
                r, g, b = pixels[x, y]
                pixel_data.extend([b, g, r])  # Packed format: B,G,R,B,G,R,... (BGR byte order)

        data_type = "uint8_t"
        bytes_per_pixel = 3

    # Generate C header file
    print(f"  Writing: {target_path}")

    # Ensure target directory exists
    target_dir = os.path.dirname(target_path)
    if target_dir and not os.path.exists(target_dir):
        os.makedirs(target_dir)

    with open(target_path, 'w') as f:
        # Header comments
        f.write(f"// Auto-generated image: {image_name}\n")
        f.write(f"// Source: {source_path}\n")
        f.write(f"// Size: {width}×{height}, Format: {format_type} ({bytes_per_pixel} bytes/pixel)\n")
        f.write("// Generated by convert_logo.py - DO NOT EDIT MANUALLY\n\n")
        f.write("#pragma once\n\n")
        f.write("#include <stdint.h>\n\n")

        # Dimension defines
        name_upper = image_name.upper()
        f.write(f"#define {name_upper}_WIDTH  {width}\n")
        f.write(f"#define {name_upper}_HEIGHT {height}\n\n")

        # Pixel data array
        if format_type == 'RGB565':
            f.write("// RGB565 pixel data (16-bit per pixel)\n")
            f.write(f"static const {data_type} {image_name}_image_data[{len(pixel_data)}] = {{\n")

            # Write data in rows of 12 values for readability
            for i in range(0, len(pixel_data), 12):
                row = pixel_data[i:i+12]
                hex_values = ', '.join(f'0x{val:04X}' for val in row)
                f.write(f"    {hex_values},\n")
        else:  # RGB888
            f.write("// RGB888 packed pixel data (3 bytes per pixel: B,G,R,B,G,R,... - BGR byte order)\n")
            f.write(f"static const {data_type} {image_name}_image_data[{len(pixel_data)}] = {{\n")

            # Write data in rows of 24 bytes (8 pixels) for readability
            for i in range(0, len(pixel_data), 24):
                row = pixel_data[i:i+24]
                hex_values = ', '.join(f'0x{val:02X}' for val in row)
                f.write(f"    {hex_values},\n")

        f.write("};\n")

    # Calculate size
    size_kb = len(pixel_data) * (2 if format_type == 'RGB565' else 1) / 1024
    pixel_count = width * height
    print(f"  Generated: {pixel_count} pixels ({size_kb:.1f} KB)")

    return True

def main():
    print("=" * 60)
    print("Tanmatsu Image Conversion Utility")
    print("=" * 60)

    # Detect screen format from main.h
    format_type = detect_screen_format()
    print(f"\nDetected format: {format_type} (from {HEADER_CONFIG})")

    # Parse XML configuration
    try:
        tree = ET.parse(XML_CONFIG)
        root = tree.getroot()
    except FileNotFoundError:
        print(f"\nError: Could not find {XML_CONFIG}")
        sys.exit(1)
    except ET.ParseError as e:
        print(f"\nError: Failed to parse {XML_CONFIG}: {e}")
        sys.exit(1)

    # Process each image
    images = root.findall('image')
    if not images:
        print(f"\nWarning: No <image> entries found in {XML_CONFIG}")
        sys.exit(0)

    print(f"\nFound {len(images)} image(s) to convert:")

    success_count = 0
    fail_count = 0

    for img_elem in images:
        source = img_elem.find('source')
        target = img_elem.find('target')
        name = img_elem.find('name')

        if source is None or target is None or name is None:
            print(f"\nError: Image entry missing required fields (source, target, name)")
            fail_count += 1
            continue

        success = convert_image(
            source.text,
            target.text,
            name.text,
            format_type
        )

        if success:
            success_count += 1
        else:
            fail_count += 1

    # Summary
    print("\n" + "=" * 60)
    print(f"Conversion complete: {success_count} succeeded, {fail_count} failed")
    print("=" * 60)

    if fail_count > 0:
        sys.exit(1)

if __name__ == "__main__":
    main()
